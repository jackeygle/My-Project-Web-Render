<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI & Robotics Portfolio - Network Crawler</title>
  <meta name="description" content="æˆ‘çš„ä½œå“é›†ï¼Œå±•ç¤ºäººå·¥æ™ºèƒ½ä¸æœºå™¨äººå­¦é¡¹ç›®ã€‚">
  <meta name="keywords" content="ä½œå“é›†, AI, äººå·¥æ™ºèƒ½, æœºå™¨äººå­¦, æ·±åº¦å­¦ä¹ , ç¥ç»ç½‘ç»œ, è®¡ç®—æœºè§†è§‰">
  <meta name="author" content="Jackeygle">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Electrolize&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary-color: #00ddff;
      --dark-color: #050810;
    }
    body {
      margin: 0;
      padding: 0;
      font-family: 'Electrolize', sans-serif;
      color: var(--primary-color);
      overflow: hidden;
      background-color: var(--dark-color);
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }
    #neural-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      cursor: none; /* éšè—é»˜è®¤å…‰æ ‡ï¼Œç”¨canvasç»˜åˆ¶è‡ªå®šä¹‰å…‰æ ‡ */
    }
    .content {
      text-align: center;
      z-index: 1;
      padding: 2.5rem;
      position: relative;
      border: 1px solid rgba(0, 221, 255, 0.3);
      background: rgba(5, 8, 16, 0.75);
      backdrop-filter: blur(10px);
      box-shadow: 0 0 50px rgba(0, 221, 255, 0.1);
    }
    .content::before, .content::after {
        content: '';
        position: absolute;
        width: 25px;
        height: 25px;
        border-color: var(--primary-color);
        border-style: solid;
        animation: border-flicker 4s infinite alternate;
    }
    .content::before { top: -6px; left: -6px; border-width: 2px 0 0 2px; }
    .content::after { bottom: -6px; right: -6px; border-width: 0 2px 2px 0; }
    h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: clamp(2rem, 5vw, 3.5rem);
      text-transform: uppercase;
      color: #fff;
      text-shadow: 0 0 8px var(--primary-color), 0 0 16px var(--primary-color);
    }
    p { text-transform: uppercase; letter-spacing: 2px; opacity: 0.8; }
    .btn-container { margin-top: 2rem; }
    .btn-futuristic {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.5rem;
      padding: 15px 30px;
      color: var(--primary-color);
      background-color: transparent;
      border: 2px solid var(--primary-color);
      text-transform: uppercase;
      transition: all 0.4s;
      cursor: pointer;
    }
    .btn-futuristic:hover {
        color: var(--dark-color);
        background-color: var(--primary-color);
        box-shadow: 0 0 30px var(--primary-color);
    }
    @keyframes border-flicker {
        0%, 100% { opacity: 0.4; }
        50% { opacity: 1; }
    }
  </style>
</head>
<body>
  <canvas id="neural-canvas"></canvas>

  <div class="content">
    <h1>Autonomous Agent</h1>
    <p>Navigating Digital Ecosystems</p>
    <div class="btn-container">
        <a href="projects.html" class="btn-futuristic">Access Logs</a>
        <a href="philosophy.html" class="btn-futuristic" style="margin-left: 1rem;">Digital Thoughts</a>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('neural-canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const mouse = { x: undefined, y: undefined, radius: 100 };
    const NODE_COUNT = (canvas.width * canvas.height) / 10000;
    const CONNECTION_RADIUS = 200;
    
    let nodes = [];

    // --- å‡çº§ç‰ˆæœºå™¨äººğŸ¤– ç±» ---
    class Robot {
        constructor() {
            this.size = 8; // èº«ä½“åŠå¾„
            this.currentNode = null;
            this.targetNode = null;
            this.previousNode = null;
            this.progress = 0; // 0 åˆ° 1 çš„ç§»åŠ¨è¿›åº¦
            this.speed = 0.005; // ç§»åŠ¨é€Ÿåº¦
            this.walkCycle = 0;
            this.x = 0;
            this.y = 0;
        }

        findNewTarget() {
            this.previousNode = this.currentNode;
            // æŸ¥æ‰¾æ‰€æœ‰é‚»å±…èŠ‚ç‚¹ï¼Œæ’é™¤åˆšç¦»å¼€çš„èŠ‚ç‚¹
            const neighbors = nodes.filter(node => {
                if (node === this.currentNode || node === this.previousNode) return false;
                const dist = Math.hypot(this.currentNode.x - node.x, this.currentNode.y - node.y);
                return dist < CONNECTION_RADIUS;
            });

            if (neighbors.length > 0) {
                // ä»æœ‰æ•ˆçš„é‚»å±…ä¸­éšæœºé€‰ä¸€ä¸ªä½œä¸ºæ–°ç›®æ ‡
                this.targetNode = neighbors[Math.floor(Math.random() * neighbors.length)];
            } else {
                // å¦‚æœæ²¡æœ‰å…¶ä»–é‚»å±…ï¼Œå°±ä»æ‰€æœ‰èŠ‚ç‚¹é‡Œéšæœºé€‰ä¸€ä¸ªï¼ˆé˜²æ­¢å¡æ­»ï¼‰
                this.targetNode = nodes.filter(n => n !== this.currentNode)[Math.floor(Math.random() * (nodes.length - 1))];
            }
        }
        
        init() {
            // éšæœºé€‰æ‹©ä¸€ä¸ªèµ·å§‹èŠ‚ç‚¹
            this.currentNode = nodes[Math.floor(Math.random() * nodes.length)];
            this.findNewTarget();
            this.x = this.currentNode.x;
            this.y = this.currentNode.y;
        }

        update() {
            if (!this.currentNode || !this.targetNode) return;

            this.progress += this.speed;
            this.walkCycle += 0.2; // æ­¥è¿›åŠ¨ç”»å¾ªç¯

            // çº¿æ€§æ’å€¼è®¡ç®—å½“å‰ä½ç½®
            const dx = this.targetNode.x - this.currentNode.x;
            const dy = this.targetNode.y - this.currentNode.y;
            this.x = this.currentNode.x + dx * this.progress;
            this.y = this.currentNode.y + dy * this.progress;

            // åˆ°è¾¾ç›®æ ‡åï¼Œé‡ç½®è¿›åº¦å¹¶å¯»æ‰¾æ–°ç›®æ ‡
            if (this.progress >= 1) {
                this.progress = 0;
                this.currentNode = this.targetNode;
                this.findNewTarget();
            }
        }

        draw() {
            if (!this.currentNode || !this.targetNode) return;
            
            ctx.save();
            ctx.translate(this.x, this.y);

            // è®¡ç®—æœå‘å¹¶æ—‹è½¬ç”»å¸ƒ
            const angle = Math.atan2(this.targetNode.y - this.currentNode.y, this.targetNode.x - this.currentNode.x);
            ctx.rotate(angle);

            const legAngle1 = Math.sin(this.walkCycle) * (Math.PI / 4);
            const legAngle2 = Math.sin(this.walkCycle + Math.PI) * (Math.PI / 4);

            // ç»˜åˆ¶å››æ¡èŠ‚è‚¢ï¼Œå‰åä¸¤å¯¹ï¼Œäº¤æ›¿æ‘†åŠ¨
            this.drawLeg(legAngle1, -this.size / 2);
            this.drawLeg(legAngle2, this.size / 2);
            this.drawLeg(legAngle2, -this.size / 2, true);
            this.drawLeg(legAngle1, this.size / 2, true);

            // ç»˜åˆ¶èº«ä½“
            ctx.beginPath();
            ctx.arc(0, 0, this.size, 0, Math.PI * 2);
            ctx.fillStyle = '#333';
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 2;
            ctx.fill();
            ctx.stroke();

            // ç»˜åˆ¶å‘å…‰çš„â€œçœ¼ç›â€
            ctx.beginPath();
            ctx.arc(this.size * 0.4, 0, this.size / 3, 0, Math.PI * 2);
            ctx.fillStyle = 'var(--primary-color)';
            ctx.shadowColor = 'var(--primary-color)';
            ctx.shadowBlur = 15;
            ctx.fill();
            ctx.shadowBlur = 0; // å…³é—­é˜´å½±ï¼Œé¿å…å½±å“å…¶ä»–å…ƒç´ 
            
            ctx.restore();
        }

        drawLeg(angle, yOffset, isBack = false) {
            ctx.strokeStyle = isBack ? '#777' : '#aaa';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, yOffset); // ä»èº«ä½“ä¾§é¢å¼€å§‹
            const kneeX = Math.cos(angle) * this.size * 1.5;
            const kneeY = yOffset + Math.sin(angle) * this.size * 1.5;
            ctx.lineTo(kneeX, kneeY); // ç”»åˆ°â€œè†ç›–â€
            ctx.lineTo(kneeX, kneeY + this.size * 1.2); // ç”»â€œå°è…¿â€
            ctx.stroke();
        }
    }

    class Node {
      constructor() {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.vx = (Math.random() - 0.5) * 0.3;
        this.vy = (Math.random() - 0.5) * 0.3;
        this.radius = Math.random() * 1.5 + 1;
      }
      update() {
        this.x += this.vx; this.y += this.vy;
        if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
        if (this.y < 0 || this.y > canvas.height) this.vy *= -1;
      }
      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0, 221, 255, 0.5)';
        ctx.fill();
      }
    }

    function init() {
      nodes = [];
      for (let i = 0; i < NODE_COUNT; i++) {
        nodes.push(new Node());
      }
      robot.init(); // åˆå§‹åŒ–æœºå™¨äºº
    }
    
    const robot = new Robot(); // å®ä¾‹åŒ–æœºå™¨äºº

    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // ç»˜åˆ¶ç¥ç»ç½‘ç»œè¿æ¥çº¿
      for(let i = 0; i < nodes.length; i++) {
          for(let j = i; j < nodes.length; j++) {
              const dist = Math.hypot(nodes[i].x - nodes[j].x, nodes[i].y - nodes[j].y);
              if (dist < CONNECTION_RADIUS) {
                  ctx.beginPath();
                  ctx.moveTo(nodes[i].x, nodes[i].y);
                  ctx.lineTo(nodes[j].x, nodes[j].y);
                  ctx.strokeStyle = `rgba(0, 221, 255, ${0.5 - dist / CONNECTION_RADIUS})`;
                  ctx.stroke();
              }
          }
      }

      // æ›´æ–°å’Œç»˜åˆ¶èŠ‚ç‚¹
      nodes.forEach(node => { node.update(); node.draw(); });
      
      // æ›´æ–°å’Œç»˜åˆ¶æœºå™¨äºº
      robot.update();
      robot.draw();

      // ç»˜åˆ¶è‡ªå®šä¹‰çš„é¼ æ ‡å…‰æ ‡
      if (mouse.x) {
          ctx.beginPath();
          ctx.arc(mouse.x, mouse.y, mouse.radius, 0, Math.PI * 2);
          const gradient = ctx.createRadialGradient(mouse.x, mouse.y, 0, mouse.x, mouse.y, mouse.radius);
          gradient.addColorStop(0, 'rgba(0, 221, 255, 0.2)');
          gradient.addColorStop(1, 'rgba(0, 221, 255, 0)');
          ctx.fillStyle = gradient;
          ctx.fill();
      }

      requestAnimationFrame(animate);
    }

    window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; init(); });
    window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
    window.addEventListener('mouseout', () => { mouse.x = undefined; mouse.y = undefined; });

    init();
    animate();
  </script>
</body>
</html>